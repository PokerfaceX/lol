### 索引

我们在视频中看到，对于600万条数据，如果我们没有创建索引，那么查询一条数据需要13s的时间，但是如果对某一列创建了索引，同时我们根据这个索引进行查找的话，那么我们就仅仅用了5ms，快了将近200倍，那这是为什么呢？



#### 索引底层结构

<img src="/Users/jasonjin/Library/Application Support/typora-user-images/image-20240604224533709.png" alt="image-20240604224533709" style="zoom:50%;" />

- 对于上述的查找，如果在age这个属性上创建索引，那么我们在做的其实就是一个全表扫描，也是一个线性搜索，linear search
- 那么如果我们想加快搜索，也就要对age属性创建一个数据结构，也就是我们的索引，而二叉平衡搜索书就能大大加快进程，将O(n)变成O(log(n))



但是！其实这样还是有问题，就是说在数据量更大的时候，即使是logn，也不行，因为层次太多了，树非常的深，检索速度还是慢，所以我们在mysql里面通过了B+树，来实现索引

![image-20240604224956278](/Users/jasonjin/Library/Application Support/typora-user-images/image-20240604224956278.png)

对于b+树，不用做到彻底精通，只要大概理解就可以了，简单来说一个节点可以有多个key，所以深度马上就降低了，当我们在查找某个数值的时候，我们先通过二分查找，来知道我们要往哪个范围，哪个child node上面找，然后一个劲的往下搜，最后在leaf node上就能搜到了(这里有一些细节不太懂)，可以看到的是，所有的non leaf node只是用来索引数据的，只有leaf node存储了真正的数据





### 优缺点

| +                                              | -                                  |
| ---------------------------------------------- | ---------------------------------- |
| 大大提高了查询的效率，减少了io成本             | 会占用存储空间                     |
| 通过索引对数据进行了排序，降低了数据排序的成本 | 降低了insert，update，delete的效率 |



当我们第一次为600万条数据创建索引的时候，我们花了几乎40s，看起来很长，但是其实不然，因为这只是一次性的操作。虽然index会占据存储空间，但是现在很多公司空间都是用t来衡量的，不算太珍贵，至于影响的insert，update，delete的效率，这也是小事。因为在日常业务中，search占据了几乎百分之90的情况。所以总的来看，indexing带来的好处是非常多的



#### index的语法

```mysql
create  [ unique ]  index 索引名 on  表名 (字段名,... ) ;
show  index  from  表名;
drop  index  索引名  on  表名;
```

- 对于每一个primary key，我们都会创建一个primary key index，这个索引是所有索引种类中最快的(?以后可以看看索引的各种种类)
- 如果一个column是unique的，那么就会自动创建一个unique index(?目前没必要看)